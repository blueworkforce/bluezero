<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BlueZero (BØ): BlueWorkforce Middleware - A brief description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueZero (BØ)
   </div>
   <div id="projectbrief">Middleware for distributed applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">BlueWorkforce Middleware - A brief description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="api"></a>
API Design</h1>
<p>The main class used to create a node is <a class="el" href="classb0_1_1_node.html" title="The abstraction for a node in the network. ">b0::Node</a>. Node uses two-phase initialization, so you must call <a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a> after the constructor, and <a class="el" href="classb0_1_1_node.html#a8b0fc9e81f907e0542657d7b591baa61" title="Node cleanup: stop all threads, send a shutdown notification to resolver, and so on... ">b0::Node::cleanup()</a> before the destructor.</p>
<p>Also, <a class="el" href="classb0_1_1_node.html#a12710a77532db0989c1def92c68e74f5" title="Read all available messages from the various ZeroMQ sockets, and dispatch them to callbacks...">b0::Node::spinOnce()</a> must be called periodically to process incoming messages (or just call <a class="el" href="classb0_1_1_node.html#a82dd059231755c8a229144748b18ec79" title="Run the spin loop (continuously call spinOnce(), at the specified rate, and call cleanup() at the end...">b0::Node::spin()</a> once).</p>
<div class="image">
<img src="node-state-machine.png" alt="node-state-machine.png"/>
<div class="caption">
Node state transtion diagram.</div></div>
<p><a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a> will initialize the node and announce its name to the resolver node, and it will initialize each of its publishers, subscribers, clients and servers.</p>
<p>Any publishers, subscribers, service client and servers must be constructed prior to calling <a class="el" href="classb0_1_1_node.html#a22299ab013b471c19f5935e3a0bede2b" title="Initialize the node (connect to resolve, start heartbeat, announce node name) ">b0::Node::init()</a>.</p>
<p>The two ways of interconnecting nodes are:</p><ul>
<li><b>services</b>, like clients and servers (functionality is provided by classes <a class="el" href="classb0_1_1_service_client.html" title="The service client class. ">b0::ServiceClient</a> and <a class="el" href="classb0_1_1_service_server.html" title="The service server class. ">b0::ServiceServer</a>)</li>
<li><b>topics</b>, like in publishers and subscribers (functionality provided by classes <a class="el" href="classb0_1_1_publisher.html" title="The publisher class. ">b0::Publisher</a> and <a class="el" href="classb0_1_1_subscriber.html" title="The subscriber class. ">b0::Subscriber</a>)</li>
</ul>
<h1><a class="anchor" id="threading"></a>
Threading and thread safety</h1>
<p>The functions of the library are not thread-safe, and so are the functions of ZeroMQ. Thus, every node must be accessed always from the same thread.</p>
<p>Also, since the identifier of a node is the triple composed by the machine hostname, the process identifier, and the thread identifier, it is not possible to have more than one node per thread. This may change in future.</p>
<h1><a class="anchor" id="resolver_intro"></a>
Resolver node</h1>
<p>The most important part of the network is the resolver node. It is implemented in <a class="el" href="classb0_1_1resolver_1_1_resolver.html" title="The resolver node. ">b0::resolver::Resolver</a> and will provide following services to other nodes:</p>
<ul>
<li>node name resolution</li>
<li>socket name resolution</li>
<li>a global XPUB/XSUB proxy</li>
<li>liveness monitoring</li>
<li>tracking of connected nodes</li>
<li>clock synchronization (see <a class="el" href="timesync.html">Time Synchronization</a>)</li>
</ul>
<p><b>Important:</b> you must have the resolver node running prior to running any node. See <a class="el" href="remote_nodes.html">Connecting remote nodes</a> for more information about running distributed nodes.</p>
<h1><a class="anchor" id="examples"></a>
Examples</h1>
<h2><a class="anchor" id="example_pubsub"></a>
Topics (Publisher/Subscriber)</h2>
<p>Example of how to create a simple node with one publisher and sending some messages to some topic:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/publisher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;publisher&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;publisher&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a Publisher to publish on topic &quot;A&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_publisher.html">b0::Publisher</a> pub(&amp;node, <span class="stringliteral">&quot;A&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i = 0;</div><div class="line">    <span class="keywordflow">while</span>(!node.shutdownRequested())</div><div class="line">    {</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Process messages from node&#39;s sockets</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        node.spinOnce();</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Create a message to send</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        std::string msg = (boost::format(<span class="stringliteral">&quot;msg-%d&quot;</span>) % i++).str();</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Send the message on the &quot;A&quot; topic</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">        pub.publish(msg);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Wait some time</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        boost::this_thread::sleep_for(boost::chrono::milliseconds(500));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the corresponding example of a simple node with one subscriber:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/subscriber.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This callback will be called whenever a message is received on any</span></div><div class="line"><span class="comment"> * of the subscribed topics</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> std::string &amp;msg)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;subscriber&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;subscriber&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a Subscriber to subscribe to topic &quot;A&quot;</span></div><div class="line"><span class="comment">     * It will call the specified callback upon receiving messages</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_subscriber.html">b0::Subscriber</a> sub(&amp;node, <span class="stringliteral">&quot;A&quot;</span>, &amp;callback);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Spin the node (continuously process incoming messages and call callbacks)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.spin();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>You can have multiple publishers and subscribers as well:</p>
<p><a class="el" href="multi_publisher_8cpp-example.html">Node with multiple publishers</a></p>
<p><a class="el" href="multi_subscriber_8cpp-example.html">Node with multiple subscribers</a></p>
<p>And following is an example of using it in a more object-oriented way:</p>
<p><a class="el" href="publisher_node_object_8cpp-example.html">OOP publisher node</a></p>
<p><a class="el" href="subscriber_node_object_8cpp-example.html">OOP subscriber node</a></p>
<h2><a class="anchor" id="example_clisrv"></a>
Services (Client/Server)</h2>
<p>Example of how to create a simple node with a service client:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/service_client.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;client&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;client&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a ServiceClient that will connect to the service &quot;control&quot;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_service_client.html">b0::ServiceClient</a> cli(&amp;node, <span class="stringliteral">&quot;control&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce the node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a request message</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::string req = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; req &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The response will be written here</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    std::string rep;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Call the service (blocking)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    cli.call(req, rep);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; rep &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the corresponding example of a simple node with a service server:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;b0/node.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;b0/service_server.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * This callback will be called whenever a request message is read from the socket</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keyword">const</span> std::string &amp;req, std::string &amp;rep)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; req &lt;&lt; std::endl;</div><div class="line">    rep = <span class="stringliteral">&quot;hi&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sending: &quot;</span> &lt;&lt; rep &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a node named &quot;server&quot;</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Note: if another node with the same name exists on the network, this node will</span></div><div class="line"><span class="comment">     *       get a different name</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_node.html">b0::Node</a> node(<span class="stringliteral">&quot;server&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Create a ServiceServer for a service named &quot;control&quot;</span></div><div class="line"><span class="comment">     * It will call the specified callback upon receiving requests.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="classb0_1_1_service_server.html">b0::ServiceServer</a> srv(&amp;node, <span class="stringliteral">&quot;control&quot;</span>, &amp;callback);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Initialize the node (will announce node name to the network, and do other nice things)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.init();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Spin the node (continuously process incoming requests and call callbacks)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.spin();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform cleanup (stop threads, notify resolver that this node has quit, ...)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    node.cleanup();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p>And the same thing, object-oriented:</p>
<p><a class="el" href="client_node_object_8cpp-example.html">OOP client node</a></p>
<p><a class="el" href="server_node_object_8cpp-example.html">OOP server node</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
